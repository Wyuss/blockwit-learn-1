     Структуры данных — способы хранения и извлечения информации.
Правильный выбор структуры поможет эффективнее выполнить задачу.
СД важны в разработке ПО, от них зависит, как будут работать алгоритмы.

    1. Дерево (Tree).
    Деревья — структура, в которой данные связаны между собой узлами, и при этом расположены иерархически.
Самый верхний узел в этой СД, не имеющий предков, называется корневым.
Остальные узлы — потомками или дочерними элементами.
Дочерние узлы с одним и тем же родителем — это узлы-братья. А листья — это узлы, не имеющие потомков.
Они позволяют разделить пространство и быстро находить объекты.
Но деревья сложно хранить и у них невысокая скорость работы.
    Примеры: 1) Как и у настоящего дерева, тут есть корни, ветви и листья. 2) используют в разработке видеоигр
    (дерево с четырьмя дочерними узлами (quadtree) — квадрант — используется для создания карты и ориентации по четырем сторонам света в игре.);
    3) Бинарное дерево; 4) быстрый поиск. Словари. Т9 (Trie ( префиксное деревое ));

    2. Связный список (Linked list).
Списки схожи с массивами, но отличаются более гибкой структурой.
Доступ к элементам в связном списке осуществляется последовательно, в отличие от массивов с произвольным доступом.
Списки бывают однонаправленными и двунаправлянными, круговыми.
Начальный элемент этой структуры называется головой, а все последующие узлы цепочки — хвостом.
Хвост состоит из элементов двух типов: с информацией (info) и с указанием на следующий узел (next). Конец цепочки обозначается как null.
    Примеры: 1) цепочка нод или узлов, где каждая нода содержит ссылку на следующую;

    3. Ассоциативный массив (Array).
Массив — это фиксированная структура, хранящая элементы одного типа в непрерывных ячейках памяти.
Есть исключение — гетерогенные массивы, которые могут хранить данные разных типов.
Массивы бывают одномерными и многомерными (массивы в массивах).
Их размеры фиксированы, поэтому в уже созданный массив нельзя просто вставить новый элемент.
Нужно скопировать старый массив и создать новый, увеличив размер.
    Примеры: 1) матрица (двумерный массив); 2) список имен; 3) список дат рождения; 4) таблица;

    4. Очередь (Queue)
    Этот тип СД напоминает стеки, но принцип работы реализован как FIFO (first in — first out, «первым пришел — первым ушел»).
В этой СД можно выполнить две операции: добавление элемента в конец очереди (enqueue) и удаление первого элемента (dequeue).
Очереди бывают в виде связных списков или массивов, по аналогии со стеками.
    Примеры: 1) очередь (последний занял последним и будешь, а первый первым ее и покинет);
    2) работа ЦП; пропускная способность роутера (ресурс нужно распределить среди нескольких потребителей);
    3) когда данные передаются асинхронно, то есть скорости приема и отдачи — разные;

    5. Стек (Stack)
    Это вертикальный столбец с блоками, доступ к которым можно получить только с одного конца: сверху или снизу.
Принцип работы такой структуры — LIFO (last in — first out, «последним пришел — первым ушел»).
Эта структура данных реализована в функции «отменить» (undo).
В стеке возможны всего три операции: добавление элемента (push), удаление (pop), чтение (peek).
Стек может быть реализован в виде связного списка или одномерного массива.
В первом случае, каждый элемент содержит ссылку на следующий, во втором — упорядочен индексом.
Существует похожая СД — дек (deque — double ended queue, «двусторонняя очередь»). Это стек с двусторонним доступом.
    Примеры: 1) стопка книг (чтобы добраться до нижней, нужно сначала убрать все книги сверху); 2) магазин
    (выстрелит патрон, который был заряжен последним);

    6. FIFO и LIFO
    FIFO — это аббревиатура « первым пришел — первым вышел» . (очередь)
Это метод для обработки структур данных, где первый элемент обрабатывается первым, а новейший элемент обрабатывается последним.
    LIFO — это сокращение от Last in, first out — то же самое, что fist in, last out (FILO). (стек)
Это метод для обработки структур данных, где последний элемент обрабатывается первым, а первый элемент обрабатывается последним.



